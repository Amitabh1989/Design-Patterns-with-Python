# Design-Patterns-with-Python with Amitabh

Welcome to this series of Design Patterns using Python. Its a live series where in I will be covering SOLID design principle + 20 Software Design Patterns : All using Python !!

## A SOLID design principle + Software Design Patterns using Python

![design-patterns-python](https://github.com/Amitabh1989/Design-Patterns-with-Python/assets/12171805/53e0c41f-7c4f-425a-b33b-79785eae219d)

## Below is the Grouped List of most commonly used distinctions for Software Design Patterns
### 1. Creational Pattern
<p> Creational patterns focus on object creation mechanisms, providing ways to create objects in a manner that enhances flexibility and reusability. These patterns abstract the instantiation process, making it independent of the specific classes or objects being created. Examples of creational patterns include Singleton, Factory Method, Abstract Factory, Builder, and Prototype. </p>

### 2. Structural Pattern
<p> Structural patterns deal with the composition of classes and objects, forming larger structures while keeping them flexible and efficient. These patterns help to define relationships between different objects and provide ways to simplify complex structures. Structural patterns often involve class and object inheritance, interface implementation, and composition. Examples of structural patterns include Adapter, Decorator, Composite, Proxy, Facade, Bridge, and Flyweight. </p>

### 3. Behavioral Pattern
<p> Behavioral patterns focus on communication and interaction between objects, defining patterns for how objects interact and distribute responsibilities. These patterns concentrate on algorithms, collaboration, and the assignment of responsibilities between objects to achieve desired behaviors. Behavioral patterns help to ensure loose coupling between objects and provide flexibility in changing behaviors at runtime. Examples of behavioral patterns include Observer, Strategy, Command, Iterator, State, Template Method, Chain of Responsibility, Visitor, Mediator, Memento, Interpreter, and Null Object.
</p>

## Software Design Patterns

<details>
<summary>Creational Patterns</summary>

1. Singleton: Ensures that a class has only one instance and provides a global point of access to it.
2. Factory Method: Defines an interface for creating objects, but allows subclasses to decide which class to instantiate.
3. Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.
4. Builder: Separates the construction of complex objects from their representation, allowing the same construction process to create various representations.
5. Prototype: Creates new objects by cloning an existing object and modifying it as required, without explicitly using class constructors.

</details>

<details>
<summary>Structural Patterns</summary>

6. Adapter: Converts the interface of a class into another interface that clients expect, allowing incompatible classes to work together.
7. Decorator: Adds new behaviors or responsibilities to individual objects dynamically, without affecting the behavior of other objects.
8. Composite: Represents a group of objects as a single object, allowing clients to treat individual objects and compositions uniformly.
9. Proxy: Provides a surrogate or placeholder for another object to control its access or add additional functionality.
10. Facade: Provides a simplified interface to a complex subsystem of classes, making it easier to use and reducing dependencies.
11. Bridge: Decouples an abstraction from its implementation, allowing both to vary independently.
12. Flyweight: Shares common state across multiple objects, reducing memory usage when dealing with large numbers of objects.

</details>

<details>
<summary>Behavioral Patterns</summary>

13. Observer: Defines a one-to-many dependency between objects, so that when one object changes state, its dependents are notified and updated automatically.
14. Strategy: Defines a family of interchangeable algorithms and encapsulates each one, allowing them to be used interchangeably.
15. Command: Encapsulates a request as an object, decoupling the sender from the receiver and allowing parameterization of clients with different requests.
16. Iterator: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.
17. State: Allows an object to alter its behavior when its internal state changes, encapsulating state-specific logic into separate classes.
18. Template Method: Defines the skeleton of an algorithm in a base class, allowing subclasses to provide specific implementations of certain steps.
19. Chain of Responsibility: Allows an object to pass a request along a chain of potential handlers until the request is handled or reaches the end of the chain.
20. Visitor: Separates an algorithm from the objects it operates on, allowing new operations to be added without modifying the objects.
21. Mediator: Defines an object that encapsulates how a set of objects interact, promoting loose coupling and reducing direct dependencies.
22. Memento: Captures and externalizes an object's internal state, allowing the object to be restored to this state later.
23. Interpreter: Defines a representation of grammar rules and interprets sentences in a language, mapping them to operations.
24. Command: Encapsulates a request as an object, decoupling the sender from the receiver and allowing parameterization of clients with different requests.
25. Null Object: Provides a no-op or neutral behavior for a class, allowing it to be used in place of other objects that provide actual implementations.

</details>
